#!/usr/bin/env python

import argparse
import base64
import os
import subprocess
import sys
import yaml

from jinja2 import Environment, Template, StrictUndefined

# Modified http://blog.endpoint.com/2015/01/getting-realtime-output-using-python.html for Python3 and stdin
def run_command(command, stdin):
    process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    process.stdin.write(str.encode(stdin))
    process.stdin.close()
    while True:
        output = process.stdout.readline().decode()
        if output == "" and process.poll() is not None:
            break
        if output:
            print(output, end="")
    rc = process.poll()
    return rc

def get_filenames(path):
    if os.path.isdir(path):
        return filter(
            lambda p: os.path.isfile(p),
            [os.path.join(path, p) for p in os.listdir(path)]
        )
    else:
        return [path]

def load_config(path):
    with open(path, "r", encoding='utf-8') as stream:
        config = yaml.load(stream)
    return config

def get_operations(operation):
    if (operation == "bounce"):
        return ["delete", "create"]
    else:
        return [operation]

def read_from_file(template_path, relative_path):
    with open(os.path.join(os.path.dirname(template_path), relative_path), "rt") as file:
        return file.read()

def run_from_template(operation, dry_run, stack_name, template_path, config):
    env = Environment(undefined=StrictUndefined)
    env.filters["b64encode"] = lambda s: base64.b64encode(s.encode()).decode("utf-8")
    with open(template_path, "rt") as file:
        template = env.from_string(file.read())

    print("--- {} [{}] [{}] ---".format(operation.upper(), stack_name, template_path))

    config["from"] = lambda relative_path: read_from_file(template_path, relative_path)
    
    rendered = template.render(config)

    if (dry_run):
        print(rendered)
    else:
        rc = run_command(["kubectl", operation, "-f", "-"], stdin=rendered)
        if rc != 0:
            raise EnvironmentError("kubectl failed")

def check_cluster(cluster_name):
    current_context = subprocess.check_output(["kubectl", "config", "current-context"]).decode("utf-8").strip()
    if not current_context.endswith(cluster_name):
        raise ValueError("stack name mismatch. configured {0} but specified {1}".format(current_context, cluster_name))

def parse_args():
    parser = argparse.ArgumentParser(description="Deploy Kubernetes stuff with templatisation.")
    parser.add_argument("-c", "--cluster", required=True,
                           help="Cluster name (should match prefix of a file in clusters/ dir)")

    subparsers = parser.add_subparsers(help="sub-command help", dest="operation")
    subparsers.required = True

    OPERATIONS = [
        ("create", "create resource"),
        ("apply", "apply configuration to a resource"),
        ("delete", "delete a resource"),
        ("bounce", "delete and recreate a resource")
    ]

    for operation, help_msg in OPERATIONS:
        subparser = subparsers.add_parser(operation, help=help_msg)

        subparser.set_defaults(operation=operation)
        subparser.add_argument("-f", "--filename", required=True,
                               help="Kubernetes definition file (or directory containing files)")
        subparser.add_argument("-e", "--environment", nargs=1, action="append", default=[],
                               help="Additional variables for template expansion")
        subparser.add_argument("-d", "--dry-run", action="store_true",
                               help="Enable dry-run mode (just prints rendered templates, no actions are taken)")
        subparser.add_argument("stack_file", nargs="*", help="Stack config files (YAML)")

    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()

    if not args.operation:
        sys.exit(1)

    check_cluster(args.cluster)
    stack_configs = {path: load_config(path) for path in args.stack_file}
    cluster_config = load_config(os.path.join("config", "clusters", args.cluster + ".yml"))
    customers = load_config(os.path.join("config", "customers.yml"))
    environment = {}
    for var in args.environment:
        bits = var[0].split("=")
        if len(bits) != 2:
            print("Malformed variable option: {}".format(var))
            sys.exit(1)
        environment[bits[0]] = bits[1]
        
    for operation in get_operations(args.operation):
        for template_path in get_filenames(args.filename):
            if template_path.endswith(".stack.yml"):
                for stack_path, stack_config in stack_configs.items():
                    run_from_template(operation, args.dry_run, stack_config["name"], 
                                      template_path, 
                                      {"cluster": cluster_config, "stack": stack_config, "environment": environment})
            else:
                run_from_template(operation, args.dry_run, "global",
                                  template_path, 
                                  {"cluster": cluster_config, "environment": environment, "customers": customers})
